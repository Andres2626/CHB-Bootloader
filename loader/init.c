
/*
* entry.c -- loader init functions
*
* Copyright (C) 2021 - 2025 andres26
*
* This file is distributed under the terms of the MIT license.
*/

#include "config.h"

#include <loader.h>
#include <fs/fs.h>
#include <fs/fat.h>
#include <sys/disk.h>
#include <sys/exec.h>
#include <sys/mm.h>
#include <sys/port.h>
#include <sys/video.h>
#include <stage1/stage1.h>

#include "const.h"
#include "types.h"

#include "lib/libc/ctype.h"
#include "lib/libc/errno.h"
#include "lib/libc/minmax.h"
#include "lib/libc/stdio.h"
#include "lib/libc/string.h"

PRIVATE u8t *kernel_load = (u8t*)KERN_BUFFER;
PRIVATE struct fs_ops curfs = {
    .name   = FAT_FS_LABEL,
    .ident  = FAT12_FS_IDENT,
    .mount  = fat_mount,
    .unmount = fat_unmount,
    .open   = fat_open,
    .read = fat_read,
    .close = fat_close
};

typedef void (*kern_jmp)(struct msys_kern_hdr *header) __attribute__((regparm(1)));

/*
 * reboot(): It enters an infinite loop until a key is pressed and then restarts the machine. 
 * defined in loader/blib.S
 */
extern void reboot(); /* blib.S */

/* 
 * panic(): The `panic()` function of `CHB` is used when recovery from an error is impossible. It 
 * typically follows the error code generated by the function that halted the program. Think of 
 * it as a simplified version of the `panic()` function in Unix. This function prints the panic 
 * message and never returns; it ultimately restarts the machine if a key is pressed.
 */
PRIVATE void panic(const char *fmt) 
{
    printf("panic: %s", fmt);
    reboot();
    
    /* just in case (infinite loop) */
    for (;;);
}

PRIVATE void error(int code) 
{   
    printf("error %i: %s\n", -code, strerror(-code));
}

PRIVATE void init_memory(struct memory_info *mem) 
{
    printf("initializing memory\n");
    
    int ret = memory_init(mem);
	if (ret < 0) {
		error(ret);
        panic("MM: memory size not found\n");
    }

#if CHB_PRINT_MEMORY_INFO
    printf("memory info:\n");
    printf("lower: %iK, upper: %iK\n", mem->lo, mem->hi);
    
	for (int i = 0; i < mem->count; i++)
        printf("block, begin: 0x%llx, len: 0x%llx, type: %li, flag: 0x%lx\n", 
	           mem->blk[i].begin, mem->blk[i].len, mem->blk[i].type, mem->blk[i].flag);
#endif
}

PRIVATE void init_root_disk(struct device *disk)
{   
    printf("initializing disk\n");

    int code = devinit(disk);
    if (code < 0) {
		error(code);
        panic("DISK: root disk not initialized\n");
    }
}

PRIVATE void init_fs(struct device *disk) 
{   
    int code = 0;
    printf("initializing filesystem\n");
    
    /* mount fs in memory */
    code = curfs.mount(disk);
    if (code < 0) {
        error(code);
        panic("FS: unable to mount filesystem\n");
    }
    
    printf("filesystem info: name: %s, number: 0x%x\n", curfs.name, disk->number);
    return;
}

PRIVATE void load_kernel(struct msys_kern_hdr *kern, const char *file) 
{
    /* load the kernel in the memory */
    printf("loading kernel\n");
    
    int code = 0;
    
    if (curfs.open(file) < 0) {
        error(SIGN(EKERN));
        panic("LOADER: unable to locate kernel in FS\n");
    }
    
    /* load kernel in memory */
    i32t read = curfs.read(kernel_load, KERN_SIZE);
    if (read < 0) {
        error(read);
        panic("LOADER: unable to push kernel in memory\n");
    }

    void *entry;
    code = elf_load(kernel_load, KERN_SIZE, &entry);
    if (code < 0) {
        error(code);
        panic("LOADER: invalid kernel executable format\n");
    } 
    
    if (entry < (void*)KERN_LOC) {
        error(SIGN(EKERNLOC));
        panic("LOADER: invalid kernel localization\n");
    }
    
    /* bootstrap kernel */
    printf("\nBooting kernel at %p.\n", entry);
    
    kern_jmp kernel_start = (kern_jmp)entry;
    kernel_start(kern);
}

void init_loader(u32t header) 
{
    struct loader_hdr *hdr = (struct loader_hdr*)(uptrt)header;
    struct device disk;
    struct video video = { 0x3, BLACK, LIGHT_GRAY, { true, 15, 16, 0, 0, 0 }};
    struct memory_info mem;
    
    disk.number = hdr->drive_number;
    disk.state = 0;
	
    /* initialize video system */
    video_init(&video);

    /* print welcome message */
    printf("Loading CHB. Please Wait...\n");
	
    if (hdr->magic != CHB_MAGIC)
        panic("invalid header magic number\n");
    
    if (hdr->size != CHB_HDR_SIZE_V06)
        panic("invalid header size number\n");

    printf("CHB version: %s\n", hdr->version);
    printf("CHB Header size: 0x%x\n", hdr->size);
    
    init_memory(&mem);
    init_root_disk(&disk);
    init_fs(&disk);
    
    struct msys_kern_hdr kern;
    kern.magic = MSYS_KERN_MAGIC;
	kern.disk = disk;
	kern.mem = mem;
	kern.vid_mode = video.mode;
    
    load_kernel(&kern, hdr->first_boot);
    
    reboot();
}