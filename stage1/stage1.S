
/*
* stage1.S -- bootsector of CHB
*
* Copyright (C) 2021 - 2025 andres26
*
* This file is distributed under the terms of the MIT license.
*/

#define ASM_FILE
#define STAGE1_FILE

#include <stage1/stage1.h>

#include <arch/x86/macros.h>

/* autogenerated by size_test */
#include <sizes.h>

#define CONV(name) name ## _msg

/* Log functions */
#define _LOG(func) MSG(CONV(func))

#define LOG(func) _LOG(func); \
				_LOG(newline)

/* use 16-bit assembly mode */		
.code16
SECTION(text)
GLOBAL(_start)
	/* special code for ensure compatibility */
	jmp	afther_bpb
	nop

.org BOOT_BPB_START

	/* This is an space commonly used in some filesystems (FAT, NTFS or HPFS) */
	
.org BOOT_BPB_END

loader_packet:
    .byte 0x10 /* size */
    .byte 0
loader_size:
    .word (LOADER_IMG_SIZE + 511) >> 9
loader_offset:
    .word 0x8000
loader_segment:
    .word 0
loader_lba:
    .long 1
    .long 0
force_lba:
    .byte 0
boot_drive:
    .byte 0
    
/* BIOS disk geometry */
sectors:
    .byte 0
heads:
    .word 0
cylinders:
    .word 0
	
afther_bpb:
	/* 
	  Some bogus BIOS doesn't charge boot sector correctly.
	  jump to 0x7c00 instead of 0:7c00 
	*/
	ljmp $0, $real_start
	
real_start: 
	cli /* secure mode. */
	
    /* set all data registers */	
	xor	%ax, %ax
	mov %ax, %ds
	mov %ax, %es 
	mov %ax, %fs 
	mov %ax, %gs 
	mov %ax, %ss
	
	/* setup stack */
	mov	$BOOT_LOC, %sp
	mov %sp, %bp
	
	/* restore interrupts */
	sti
    
	_LOG(welcome)
    _LOG(newline)
    
    /* check if drive is a floppy (check bit 7) */
    test $0x80, %dl
	jz chs_mode
    
    mov %dl, boot_drive
    
    /* check if extensions are present */
    mov $0x41, %ah
    mov $0x55aa, %bx
    int $0x13
    
    /* check signature */
    jc chs_mode
    cmpw $0xaa55, %bx
	jne	chs_mode
    
    /* check if force lba is true */
    movb force_lba, %al
    testb %al, %al
	jnz	lba_mode
    
    /* check API subset support bitmap */
	andw $1, %cx
	jz chs_mode
    
lba_mode:
    /* load stage2 with disk extensions */
    mov $loader_packet, %si
    mov boot_drive, %dl
    mov $0x42, %ah
    int $0x13
    
    jc chs_mode
    
    jmp load_stage2
    
chs_mode:
    /* get disk geometry via INT13,8 */
    movb $0x8, %ah
    mov boot_drive, %dl
    int $0x13
    
    /* 
     * Some BIOS doesn't report floppy geometry correcly. then they must be obtained by brute 
     * force. 
     */
    jnc floppy_read
    
    /* the drive is a floppy and have invalid data */
    testb $0x80, %dl
	jz floppy_test
    
    /* the drive is HDD and doesn't work */
    jmp	hdd_error

floppy_read:
    /* set data localization */
    mov $sectors, %si
    
    /* get sectors */
    mov %cl, %al
    and $0x3f, %al
    movb %al, (%si) /* save SPT */
    
    /* get heads */
    mov %dh, %al
    inc %al
    movb %al, 2(%si) /* save HPC */
    
    /* get stage2 sector number */
    movl loader_lba, %eax
    
    /* convert LBA to CHS */
    
    /* check valid values */
    xor %dx, %dx
    mov (%si), %cx 
    div %cx 
    mov %dl, %cl 
    inc %cl

    xor %dx, %dx
    mov 2(%si), %cx
    div %cx
    mov %dl, %dh

chs_load:

    /* load all loader */
    
    /* segment = 0 */
    xor %ax, %ax
    mov %ax, %es
    
    /* loader offset, segment = 0 */
    mov loader_size, %al
    movb $0x2, %ah
    movw $0x8000, %bx
    mov boot_drive, %dl
    
    /* function 2 */
    int	$0x13
    
    jc read_error

load_stage2:
    xor	%ax, %ax
	mov %ax, %ds
	mov %ax, %es 
	mov %ax, %fs 
	mov %ax, %gs 
	mov %ax, %ss
    
    mov boot_drive, %dl
    
	/* jump to loader */
	ljmp $0x0, $0x8000
	jmp stop

geometry_error:
    _LOG(geometry_error)
    jmp error

read_error:
    _LOG(read_error)
    jmp error

hdd_error:
    _LOG(hdd_error)
    jmp error

floppy_error:
    _LOG(floppy_error)

error:
    _LOG(general_err)
    _LOG(newline)

boot_error:    
    /* if key is pressed reboot system */
	xorw %ax, %ax
	int	$0x16
    
    ljmp $0xf000, $0xfff0
    
stop:
	jmp stop

welcome_msg:
    .string "CHB Loading "
sucsess_msg:
    .string "YES!"
read_error_msg:
    .string "READ "
hdd_error_msg:
    .string "HDD "
geometry_error_msg:
    .string "GEOM "
general_err_msg:
    .string "ERROR."
newline_msg:
    .string "\r\n"

/* print string with INT10,0x0E */
_print:
	pusha
1:
	lodsb
	or %al, %al
	jz 2f
	mov	$0x0e, %ah
	mov	$0x0, %bx
	int	$0x10
	jmp	1b
2:
	popa
	ret

/* MBR */
.org MBR_START

mbr_magic:
    .long 0
    .word 0

floppy_error_msg:
    .string "FLOPPY "

/* sectors per track possible values */
floppy_sector_values:
    .byte 36, 18, 15, 9, 0
/* 
 * On floppy disks the MBR is not used, therefore CHB places the code to test the possible 
 * floppy disk parameters here 
 */
floppy_test:
    /* setup buffer */
    mov $(floppy_sector_values-1), %si
test_loop:
    
    /* reset controller */
    xor %ax, %ax
    
    /* prepare %al for loop */
    mov $1, %al /* 1 sector to read */
    mov boot_drive, %dl
    int $0x13
    
    inc %si
    movb (%si), %cl
    
    cmp $0, %cl
    je floppy_error
    
    /* read second sector */
    mov $0x8000, %bx
    mov $0x2, %ax
    mov $0, %ch
	mov $0, %dh
    mov boot_drive, %dl
    int	$0x13
    
    jc test_loop
    
    /* correct values */
    mov $1, %dh
	mov $79, %ch

	jmp	floppy_read

/* for make an bootable image the code must have following code. */
.org BOOT_PART_SIZE
.word BOOT_MAGIC /* 0xaa55 */